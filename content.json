{"meta":{"title":"我的主页","subtitle":null,"description":null,"author":"梦里不知身是客","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Linux定时任务系统 Cron","slug":"Linux定时任务系统-Cron","date":"2017-02-11T06:19:33.000Z","updated":"2017-02-11T08:16:08.112Z","comments":true,"path":"2017/02/11/Linux定时任务系统-Cron/","link":"","permalink":"http://yoursite.com/2017/02/11/Linux定时任务系统-Cron/","excerpt":"","text":"Linux定时任务系统 Cron 运行计划任务时:service crond restart提示：crond: unrecognized service安装计划任务：yum -y install vixie-cron 另外附计划任务的一些使用方法http://bbs.fengyn.com/read-htm-tid-3813-keyword-%BC%C6%BB%AE%C8%CE%CE%F1.html cron是一个linux下的定时执行工具，可以在无需人工干预的情况下运行作业。由于Cron 是Linux的内置服务，但它不自动起来，可以用以下的方法启动、关闭这个服务： /sbin/service crond start //启动服务 /sbin/service crond stop //关闭服务 /sbin/service crond restart //重启服务 /sbin/service crond reload //重新载入配置 你也可以将这个服务在系统启动的时候自动启动： 在/etc/rc.d/rc.local这个脚本的末尾加上： /sbin/service crond start 现在Cron这个服务已经在进程里面了，我们就可以用这个服务了，Cron服务提供以下几种接口供大家使用： 1.直接用crontab命令编辑 cron服务提供crontab命令来设定cron服务的，以下是这个命令的一些参数与说明： crontab -u //设定某个用户的cron服务，一般root用户在执行这个命令的时候需要此参数 crontab -l //列出某个用户cron服务的详细内容 crontab -r //删除没个用户的cron服务 crontab -e //编辑某个用户的cron服务 比如说root查看自己的cron设置：crontab -u root -l 再例如，root想删除fred的cron设置：crontab -u fred -r 在编辑cron服务时，编辑的内容有一些格式和约定，输入：crontab -u root -e 进入vi编辑模式，编辑的内容一定要符合下面的格式：/1 ls &gt;&gt; /tmp/ls.txt 这个格式的前一部分是对时间的设定，后面一部分是要执行的命令，如果要执行的命令太多，可以把这些命令写到一个脚本里面，然后在这里直接调用这个脚本 就可以了，调用的时候记得写出命令的完整路径。时间的设定我们有一定的约定，前面五个号代表五个数字，数字的取值范围和含义如下： 分钟 （0-59） 小時 （0-23） 日期 （1-31） 月份 （1-12） 星期 （0-6）//0代表星期天 除了数字还有几个个特殊的符号就是”“、”/”和”-“、”,”，代表所有的取值范围内的数字，”/”代表每的意思,”/5”表示每5个单位，”-“代表从某个数字到某个数字,”,”分开几个离散的数字。以下举几个例子说明问题： 每天早上6点 0 6 echo “Good morning.” &gt;&gt; /tmp/test.txt //注意单纯echo，从屏幕上看不到任何输出，因为cron把任何输出都email到root的信箱了。 每两个小时 0 /2 echo “Have a break now.” &gt;&gt; /tmp/test.txt 晚上11点到早上8点之间每两个小时，早上八点 0 23-7/2，8 echo “Have a good dream：）” &gt;&gt; /tmp/test.txt 每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点 0 11 4 1-3 command line 1月1日早上4点 0 4 1 1 command line 每次编辑完某个用户的cron设置后，cron自动在/var/spool/cron下生成一个与此用户同名的文件，此用户的cron信息都记录在这 个文件中，这个文件是不可以直接编辑的，只可以用crontab -e 来编辑。cron启动后每过一份钟读一次这个文件，检查是否要执行里面的命令。因此此文件修改后不需要重新启动cron服务。 2.编辑/etc/crontab 文件配置cron cron服务每分钟不仅要读一次/var/spool/cron内的所有文件，还需要读一次/etc/crontab,因此我们配置这个文件也能运用 cron服务做一些事情。用crontab配置是针对某个用户的，而编辑/etc/crontab是针对系统的任务。此文件的文件格式是： SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root //如果出现错误，或者有数据输出，数据作为邮件发给这个帐号 HOME=/ //使用者运行的路径,这里是根目录 # run-parts 01 root run-parts /etc/cron.hourly //每小时执行/etc/cron.hourly内的脚本 02 4 root run-parts /etc/cron.daily //每天执行/etc/cron.daily内的脚本 22 4 0 root run-parts /etc/cron.weekly //每星期执行/etc/cron.weekly内的脚本 42 4 1 root run-parts /etc/cron.monthly //每月去执行/etc/cron.monthly内的脚本 大家注意”run-parts”这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是文件夹名了。 来源：chinalinuxpub ////////////////////////////Linux中crontab是实现定时执行的指令，利用这个指令我们就可以定时执行某一个php文件，从而实现用PHP做Linux自动执行脚本。 如何用PHP作Linux自动执行脚本？ 在安装PHP的时候,会产生一个可执行文件,文件名为php.将它 copy 到 /usr/local/bin 下.在终端方式执行php程序: php -q onlinnum.php PHP 原本是应用在网页应用的﹐因此它会送出 HTML 的HEADER﹐但是在此我们是要将 PHP 用作 Shell Script﹐”-q”就是表示不要送 出 HEADER 的意思.你可以试试看不加上 -q 的显示结果。此时你已经可以在终端方式下执行PHP 代码了。 linux命令：cron daemon 这是一个系统中常驻的服务，功能在于执行例行性的工作，如每天一次或每月一 次检查磁盘。cron daemon 会在每分钟检查一次排定的工作表（crontab），看看是否有要执行的指令，所有的输出会以mail寄给用户。 设置 crontab 命令：crontab -e 该命令呼叫vi编辑器来编辑执行的清单。例如 0 0 1,15 fsck /home 1 /home/myhome/printhello 每一行代表一项排定的工作，在指令前为排定的时间，总共有5个栏位，以空格间隔，由左到右依序如下： ————————– 分钟 从00到 99 点钟 从0到 24 日 从01到31 月 从01到12 星期 从01到07，代表星期一到星期日 号表示”每” ，如每天执行，就在第三栏填号 ————————– 所以上例的两项工作是： 每月1号和15号检查/home 磁盘 每小时的第一分执行 /home/myhome/printhello 这个文件 查看crontab：crontab -l 删除crontab：crontab -r 我们就知道该怎么利用PHP和crontab命令作Linux自动执行脚本了。 还需要注意什么问题？ 如果php中有使用数据库，如oracle等，执行脚本中还需export Oracle的环境设置。因为cron下的脚本执行的用户都是在没登陆状态下执行的，少了很多系统里设置的环境变量的值，在连接数据库的时候会出问题","categories":[],"tags":[]},{"title":"都是 Edge(IE) 缓存惹的祸","slug":"都是-Edge-IE-缓存惹的祸","date":"2017-02-11T06:00:22.000Z","updated":"2017-02-11T08:16:12.053Z","comments":true,"path":"2017/02/11/都是-Edge-IE-缓存惹的祸/","link":"","permalink":"http://yoursite.com/2017/02/11/都是-Edge-IE-缓存惹的祸/","excerpt":"","text":"上周某天上班的时候，突然后端同志私戳我， 当时我正研究着另一个项目的PSD，内心认真规划着整个项目的代码结构，指尖流淌出迷人的键盘音……好吧，其实内心想着中午吃什么菜，喝什么汤仔细一看，第一反应是，怎么可能。于是爸爸我连忙打开虚拟机中滴 Win10，等待 Win10 爷爷慢悠悠的进入待机状态。迅速点开 Edge 。打开网页和 network 控制台，迅速进入调试状态。一点退出登录，“啪”一个退出请求出现在 network 里，账号也随之退出。这…不是很正常嘛？？？ 哦，是第二次，于是爸爸再次登录，点击退出。嗯？点击退出。嗯？点击退出。嗯？？？为什么页面只是刷新了一下而没有退出？？？看看 network ，空空如也。同样的操作在 Chrome 下，正常 当时我的反应是——我可能打开的是假 Edge 根据之前的表现（就是点完页面刷新了一下），我一开始假设 Edge 下 a 标签 href 里写 javascript:; 不起作用，还是会跳转，于是绑定的事件也没用了。但是一看代码，好像不对。来，看代码： 12345$(‘.J_exit’).on(‘click’, function () { $.get(‘/ajax/exit.do, function () { location.reload(); });});点击退出按钮的时候请求退出接口，后端会删除对应的 session，然后前端刷新下也没，cookie 没有对应的 session 于是会跳到登录页，从逻辑上来说，没毛病。所以排除我刚刚的假设，那会不会是缓存问题呢？刚想到这里……就看到两个人气势汹汹的往我这来，是后端GG和测试MM，两人过来把我团团围住，“Hey，boy，Edge 的 Bug 改的怎么样了？”我当时的表情是这样的， 这好像才过去三分钟，你两怎么就过来了？？？ 爸爸才刚打开虚拟机！咦，不对，重点是，为啥你两亲自跑过来了？ 宝宝很惶恐啊，有事私戳我就行了，没必要兴师动众的。由于我还没验证出 bug 原因，都是猜测，于是保守的说还母鸡呀。然后说了一堆有的没的，就走了，走了，了 哦，后台GG走之前意味深长的跟我说了句，可能是浏览器缓存问题。嘴角带着邪魅的笑，大概是这种 。爸爸刚想测。于是爸爸在请求后面加了时间戳参数，第二次请求成功的发出去了。但是还是得向后台GG表示“感谢”事后搜了下，发现 IE 浏览器对于没有明确表明是否缓存（强制缓存或者强制不缓存），默认的设置是“自动 automatically”，即在不关闭浏览器的情况下（同一个会话），刷新页面，对于相同url的请求并不会再次发送（即请求被缓存了），而 Edge 延续了 IE 这种“优良”的传统，坚决和主流浏览器保持“差异性”，所以会出现上面第二次请求退出接口的时候，请求都没有发出，直接就执行 location.reload() 了。 最后只想 po 一张图，自己体会","categories":[],"tags":[]},{"title":"冒泡排序法","slug":"1000个苹果分成10堆","date":"2016-02-11T06:19:33.000Z","updated":"2017-02-11T08:29:53.769Z","comments":true,"path":"2016/02/11/1000个苹果分成10堆/","link":"","permalink":"http://yoursite.com/2016/02/11/1000个苹果分成10堆/","excerpt":"","text":"问题：1000个苹果分成10堆，可以组合任意1-1000个数的苹果此问题是否有解？如何求解？1.首先我们必须写一个验证的程序123456789101112131415161718192021222324252627 /** * 验证数组 * @author syh * @param array $arr * @return bool */ function check($arr) &#123; rsort($arr);//逆序 $listNum=range(1,array_sum($arr)); $fun=function ($num) use ($arr)&#123; foreach ($arr as $key =&gt; $val) &#123; if($num===$val) return true; //减去数组中比自己小的最大值 if($num&gt;$val) $num=$num-$val; &#125; return false; &#125;; return !in_array(false,array_map($fun,$listNum)); &#125;$arr=[1,2,4,8,16,32,64,128,256,489];//此数组为正解的一种，可以通过验证$data=check($arr);var_dump($data);//true 2.遍历所有可能的组合或随机取值2.0非递归遍历（最原始的实现） 1234567891011121314151617181920212223242526272829303132333435363738394041/** * $m个苹果分为4堆 * @author syh * @param int $m苹果总数 * @return array 验证通过后的数组 */ function test($m) &#123; $listAll=[]; $list=[]; $len=4;//苹果堆数 $max=function($list) use ($m,$len)&#123; return $m-array_sum($list)-($len-count($list))+1; &#125;; for ($k1=1,$max1=$max($list);$k1 &lt;=$max1; $k1++) &#123; $list[1]=$k1; for ($k2=1,$max2=$max($list);$k2 &lt;=$max2 ;$k2++) &#123; $list[2]=$k2; for ($k3=1,$max3=$max($list);$k3 &lt;=$max3; $k3++) &#123; $list[3]=$k3; $list[4]=$m-array_sum($list); if(check($list)) &#123; $listAll[]=$list; &#125; unset($list[3]); unset($list[4]); &#125; unset($list[2]); &#125; unset($list[1]); &#125; return $listAll; &#125; 2.1第一种遍历所有可能， 123456789101112131415161718192021222324252627282930313233343536373839/*** 递归实现1* @author int $m 苹果的个数* @param int $n 苹果堆数* @return array*/function crateArr($m,$n)&#123; static $list=[];//保存当前的组合 static $listAll=[];//保存所有可能的组合 static $count=0,$len; if(($count++)===0) $len=$n;//保存数组长度 $max=$m-array_sum($list)-($len-count($list))+1; for ($i=1;$i&lt;=$max;$i++) &#123; $list[$n]=$i;//第$n堆苹果 if ($n===2) &#123; //此处为最后一次循环 $list[$n-1]=$m-array_sum($list);//最后一堆苹果的个数 if (check($list)) &#123; $listAll[]=$list; //验证通过后合并 &#125; unset($list[$n-1]); unset($list[$n]); &#125; elseif($n&gt;2) &#123; crateArr($m,$n-1);//递归进行 相当于for循环嵌套 unset($list[$n]); &#125; &#125; return $listAll;//返回所有符合要求的组合 &#125; 2.2第一种遍历的次数太多，进一步优化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** *递归实现2 * @author syh * @param string $m 苹果总数 * @param string $n 苹果堆数 * @param string $p 第一堆苹果起始值 * @return array */function createArr($m,$n,$p=1)&#123; static $list=[],$listAll=[]; static $count=0,$len; if(($count++)===0) $len=$n;//保存数组长度 $d=$len-($len-$n)-1;//第$n项到$len-1项的元素个数 // 假设第$n堆苹果到$len-1堆苹果数位公差为1的等差数列 //最后一堆苹果个数=苹果总和-当前堆前面的总和-当前堆到第$len-1堆等差数列的和 //第$len-1堆苹果的个数为a1+(n-1)*d 等差数列第n项公式 //当前堆到$len-1的总和为a1*n+n*(n-1)*d/2等差数列前n项和 // 数组为从小到大排序，当最后一项与倒数第二项相等时为每堆苹果的最大值，即临界点 $max=($m-array_sum($list)-$d*($d-1)/2-$len+1)/($d+1)+1; for ($i=$p;$i&lt;=ceil($max);$i++) &#123; $list[$n]=$i; if ($n===2) &#123; $list[$n-1]=$m-array_sum($list); if(check($list)) &#123; // 验证通过后存入数组 $listAll[]=$list; &#125; unset($list[$n-1]); unset($list[$n]); &#125; elseif($n&gt;2) &#123; $function=__FUNCTION__; //堆数递减，后面堆苹果最小个数=前面堆苹果个数+1 $function($m,$n-1,$i+1); unset($list[$n]); &#125; &#125; return $listAll; &#125; 2.3随机取值 12345678910111213function crateArr($sum,$len) &#123; while(1) &#123; $arr=[]; for ($j=1; $j&lt;=$len; $j++) &#123; $max=$sum-array_sum($arr)-($len-count($arr))+1; $arr[$j]=($j==$len)?$sum-array_sum($arr):mt_rand(1,$max); &#125; if(check($arr)) var_dump($arr); &#125; &#125; 总结：经过自己不懈的努力，程序终于实现了；但1000个苹果分成10堆计算量太大，自己的电脑最多能计算300个苹果分成10堆。1,2,4,8,16,32,64,128,256,489通过观察得出，符合此规律的等比数列，能组合的最大数为2的（数列长度）次方-1。通过程序验证63（2^6-1）个苹果分成6堆苹果只有一个解，小于63就会存在多解；同理，1000个苹果分成10堆，能组合的最大数为2^10-1（1023）;所以此问题存在多解，上面的数列只是其中一种解。2.4 进一步研究，求全部解 1234567891011121314151617181920212223242526272829303132333435363738394041/*** 遍历后2位* 此解并不是最终解* @author syh* @return array*/function checkAll()&#123; $arr=[1,2,4,8,16,32,64,128,256,489]; $list=[]; for ($i=256; $i &gt;128 ; $i--) &#123; array_pop($arr); array_pop($arr); array_push($arr, $i,745-$i); if (check($arr)) &#123; $list[]=implode(&apos;--&apos;,$arr); &#125; &#125; return $list;&#125; $data=checkAll($arr); echo &apos;&lt;pre&gt;&apos;; print_r($data); Array( [0] =&gt; 1--2--4--8--16--32--64--128--256--489 [1] =&gt; 1--2--4--8--16--32--64--128--255--490 [2] =&gt; 1--2--4--8--16--32--64--128--254--491 [3] =&gt; 1--2--4--8--16--32--64--128--253--492 [4] =&gt; 1--2--4--8--16--32--64--128--252--493 [5] =&gt; 1--2--4--8--16--32--64--128--251--494 [6] =&gt; 1--2--4--8--16--32--64--128--250--495 [7] =&gt; 1--2--4--8--16--32--64--128--249--496 [8] =&gt; 1--2--4--8--16--32--64--128--248--497 [9] =&gt; 1--2--4--8--16--32--64--128--247--498 [10] =&gt; 1--2--4--8--16--32--64--128--246--499 [11] =&gt; 1--2--4--8--16--32--64--128--245--500) 遍历后3位有42种解,遍历后4位电脑又罢工了","categories":[],"tags":[]},{"title":"冒泡排序法","slug":"冒泡排序法","date":"2016-02-11T06:19:33.000Z","updated":"2017-02-11T08:16:04.388Z","comments":true,"path":"2016/02/11/冒泡排序法/","link":"","permalink":"http://yoursite.com/2016/02/11/冒泡排序法/","excerpt":"","text":"冒泡排序法 思路分析：法如其名，就是像冒泡一样，每次从数组当中 冒一个最大的数出来。 比如：2,4,1 // 第一次 冒出的泡是4 2,1,4 // 第二次 冒出的泡是 2 1,2,4 // 最后就变成这样 $arr=array(1,43,54,62,21,66,32,78,36,76,39);function getpao($arr){ $len=count($arr); //设置一个空数组 用来接收冒出来的泡 //该层循环控制 需要冒泡的轮数 for($i=1;$i&lt;$len;$i++) { //该层循环用来控制每轮 冒出一个数 需要比较的次数 for($k=0;$k&lt;$len-$i;$k++) { if($arr[$k]&gt;$arr[$k+1]) { $tmp=$arr[$k+1]; $arr[$k+1]=$arr[$k]; $arr[$k]=$tmp; } } } return $arr;}","categories":[],"tags":[]},{"title":"快速排序法","slug":"快速排序法","date":"2016-02-11T06:19:33.000Z","updated":"2017-02-11T08:15:58.558Z","comments":true,"path":"2016/02/11/快速排序法/","link":"","permalink":"http://yoursite.com/2016/02/11/快速排序法/","excerpt":"","text":"快速排序法代码如下: function quick_sort($arr) { //先判断是否需要继续进行 $length = count($arr); if($length &lt;= 1) { return $arr; } //如果没有返回，说明数组内的元素个数 多余1个，需要排序 //选择一个标尺 //选择第一个元素 $base_num = $arr[0]; //遍历 除了标尺外的所有元素，按照大小关系放入两个数组内 //初始化两个数组 $left_array = array();//小于标尺的 $right_array = array();//大于标尺的 for($i=1; $i&lt;$length; $i++) { if($base_num &gt; $arr[$i]) { //放入左边数组 $left_array[] = $arr[$i]; } else { //放入右边 $right_array[] = $arr[$i]; } } //再分别对 左边 和 右边的数组进行相同的排序处理方式 //递归调用这个函数,并记录结果 $left_array = quick_sort($left_array); $right_array = quick_sort($right_array); //合并左边 标尺 右边 return array_merge($left_array, array($base_num), $right_array);}","categories":[],"tags":[]}]}